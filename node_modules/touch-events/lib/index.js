'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.setConfig = setConfig;
exports.default = createListener;
exports.__unload = __unload;

require('pepjs');

var _eventdispatcher = require('eventdispatcher.js');

var _eventdispatcher2 = _interopRequireDefault(_eventdispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CONFIG = {
  DRAG_THRESHOLD: 10
};
function setConfig(config) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = CONFIG[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (config[key] !== undefined) {
        CONFIG[key] = config[key];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var listeners = [];
var pointers = {};

function createListener(DOMNode) {
  // Check if already listening to DOM Node
  var listener = listeners.find(function (listener) {
    return listener.DOMNode === DOMNode;
  });
  if (listener) return listener.DOMNode;

  // Set touch action to none of DOM element
  // Necessary for Pointer Events Polyfill
  DOMNode.setAttribute('touch-action', 'none');

  var eventDispatcher = new _eventdispatcher2.default();
  // Each dom node has it's own state and linked pointers so there can be
  // different gestures to different DOM nodes at the same time
  // Pointers are linked to a DOM node when the pointer down event has a target of the DOM node
  var state = {
    currentEvent: 'idle',
    pointers: []
  };
  listeners.push({ DOMNode: DOMNode, eventDispatcher: eventDispatcher, state: state });

  // Wheel event is handled here
  DOMNode.addEventListener('wheel', function (event) {
    return eventDispatcher.dispatchEvent({ type: 'wheel', event: event });
  });

  return eventDispatcher;
}

// Some util function to be used in eventRegonizer
//   getCurrentEvents: returns array of current pointer events from a listener object
var getCurrentEvents = function getCurrentEvents(_ref) {
  var state = _ref.state;
  return state.pointers.map(function (_ref2) {
    var event = _ref2.event;
    return event;
  });
};
//   resetPointersStart: updates start event to current event of all pointers of a listener object
var resetPointersStart = function resetPointersStart(_ref3) {
  var state = _ref3.state;
  return state.pointers.forEach(function (pointer) {
    pointer.start = pointer.event;
    pointer.preEvents = [pointer.event];
  });
};

function eventRegonizer(event) {
  var pointerId = event.pointerId,
      type = event.type;


  switch (type) {
    case 'pointerdown':
      {
        var _listener = listeners.find(function (_ref4) {
          var DOMNode = _ref4.DOMNode;
          return DOMNode === event.target;
        });

        if (!_listener) break;

        var pointer = { event: event, start: event, preEvents: [event], listener: _listener };
        if (_listener.state.pointers.length >= 1) {
          // end current event because after a new pointer is added a new event is triggered
          var events = getCurrentEvents(_listener);

          var _type = _listener.state.currentEvent + 'end';
          if (_listener.state.currentEvent === 'drag') {
            var _events = _slicedToArray(events, 1),
                _event = _events[0];

            _listener.eventDispatcher.dispatchEvent({ type: _type, event: _event });
          } else {
            _listener.eventDispatcher.dispatchEvent({ type: _type, events: events });
          }
        }

        // store pointer in pointers object and increase num pointers
        pointers[pointerId] = pointer;
        _listener.state.pointers.push(pointer);

        // start multitouch event
        // note, drag event is NOT started here, the drag event starts after moved DRAG_THRESHOLD
        if (_listener.state.pointers.length >= 2) {
          _listener.state.currentEvent = 'multitouch';

          var _events2 = getCurrentEvents(_listener);
          _listener.eventDispatcher.dispatchEvent({ type: _listener.state.currentEvent + 'start', events: _events2 });
        }

        break;
      }
    case 'pointermove':
      {
        var _pointer = pointers[pointerId];
        // end when pointer is not known
        // this can happen when a pointer started outside a known dom node
        if (!_pointer) break;

        // update pointer
        _pointer.event = event;

        var _listener2 = _pointer.listener;

        // different behaviour based on current event

        switch (_listener2.state.currentEvent) {
          case 'idle':
          case 'idle-drag':
            var preEvents = _pointer.preEvents,
                start = _pointer.start;

            // add current position to predrags

            _pointer.preEvents.push(event);

            // when event is idle check if pointer has moved more then DRAG_THRESHOLD
            var deltaX = start.clientX - event.clientX;
            var deltaY = start.clientY - event.clientY;
            var distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
            if (distance > CONFIG.DRAG_THRESHOLD) {
              // check if left or right mousebutton (for tablets this always is drag)
              _listener2.state.currentEvent = event.buttons & 2 ? 'seconddrag' : 'drag';

              // dispatch event with current position and an array with positions before drag was triggered
              _listener2.eventDispatcher.dispatchEvent({
                type: _listener2.state.currentEvent + 'start',
                event: start,
                preEvents: preEvents
              });
            }
            break;
          case 'drag':
          case 'seconddrag':
            // dispatch drag event with current pointer position
            _listener2.eventDispatcher.dispatchEvent({ type: _listener2.state.currentEvent, event: event });
            break;
          case 'multitouch':
            // dispatch multitouch event with current pointer positions (>= 2)
            var _events3 = getCurrentEvents(_listener2);

            _listener2.eventDispatcher.dispatchEvent({ type: _listener2.state.currentEvent, events: _events3 });
            break;
          default:
            break;
        }
        break;
      }
    case 'pointercancel':
    case 'pointerleave':
    case 'pointerup':
      {
        var _pointer2 = pointers[pointerId];

        // end when pointer is not known
        // this can happen when a pointer started outside the screen
        if (!_pointer2) break;

        // update pointer
        _pointer2.event = event;

        var _listener3 = _pointer2.listener;

        // emit multitouch end before pointer is deleted

        if (_listener3.state.currentEvent === 'multitouch') {
          // end current event so a new one can be started
          var _events4 = getCurrentEvents(_listener3);
          _listener3.eventDispatcher.dispatchEvent({ type: _listener3.state.currentEvent + 'end', events: _events4 });
        }

        // remove pointer from pointer objects and decrease num pointers
        delete pointers[pointerId];
        _listener3.state.pointers.splice(_listener3.state.pointers.indexOf(_pointer2), 1);

        switch (_listener3.state.currentEvent) {
          case 'multitouch':
            var _events5 = getCurrentEvents(_listener3);

            resetPointersStart(_listener3);

            if (_listener3.state.pointers.length === 1) {
              // when only on one pointer is left on the screen this pointer can become multitouch or drag
              // so set it to idle drag so it can't become tab
              _listener3.state.currentEvent = 'idle-drag';

              // reset preEvents with current position
              _pointer2.preEvents = [_events5[0]];
            } else if (_listener3.state.pointers.length > 1) {
              // dispatch event for new composition of pointers
              _listener3.eventDispatcher.dispatchEvent({ type: _listener3.state.currentEvent + 'start', events: _events5 });
            }
            break;
          case 'drag':
          case 'seconddrag':
            // end drag event and set currentEvent to idle (0 pointers left at this point)
            _listener3.eventDispatcher.dispatchEvent({ type: _listener3.state.currentEvent + 'end', event: event });
            _listener3.state.currentEvent = 'idle';
            break;
          case 'idle':
            // pointer has not dragged more as DRAG_THRESHOLD so pointer is regonized as tab
            _listener3.eventDispatcher.dispatchEvent({ type: 'tap', event: event });
            break;
          case 'idle-drag':
            // set currentEvent to idle if no pointers are left
            _listener3.state.currentEvent = 'idle';
            break;
          default:
            break;
        }
        break;
      }
    default:
      break;
  }

  var listener = listeners.find(function (_ref5) {
    var DOMNode = _ref5.DOMNode;
    return DOMNode === event.target;
  });
  if (listener) listener.eventDispatcher.dispatchEvent(event);
}

function onblur() {
  for (var pointerId in pointers) {
    delete pointers[pointerId];
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = listeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var listener = _step2.value;

      if (['drag', 'seconddrag', 'multitouch'].includes(listener.state.currentEvent)) {
        listener.eventDispatcher.dispatchEvent({ type: listener.state.currentEvent + 'end', event: event });
      }

      listener.state = {
        currentEvent: 'idle',
        pointers: []
      };
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

window.addEventListener('pointerdown', eventRegonizer);
window.addEventListener('pointermove', eventRegonizer);
window.addEventListener('pointerup', eventRegonizer);
window.addEventListener('pointerover', eventRegonizer);
window.addEventListener('pointerout', eventRegonizer);
window.addEventListener('pointerleave', eventRegonizer);
window.addEventListener('pointercancel', eventRegonizer);
window.addEventListener('blur', onblur);

function __unload() {
  window.removeEventListener('pointerdown', eventRegonizer);
  window.removeEventListener('pointermove', eventRegonizer);
  window.removeEventListener('pointerup', eventRegonizer);
  window.removeEventListener('pointerover', eventRegonizer);
  window.removeEventListener('pointerout', eventRegonizer);
  window.removeEventListener('pointerleave', eventRegonizer);
  window.removeEventListener('pointercancel', eventRegonizer);
  window.removeEventListener('blur', onblur);
}
//# sourceMappingURL=index.js.map