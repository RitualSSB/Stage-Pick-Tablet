<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Stagelist</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <div class="stage-container">
      <div class="starter-container"></div>
      <div class="counterpick-container"></div>
    </div>
    <script>
      const startersContainer = document.querySelector(".starter-container");
      const counterpicksContainer = document.querySelector(
        ".counterpick-container"
      );
      const socket = io();
      var stages_initialized = false;

      // Function to create a container with an image inside
      function createImageContainer(src) {
        const container = document.createElement("div");
        container.classList.add("stage");
        container.addEventListener("touchstart", strikeOutStageEvent);
        container.addEventListener("click", strikeOutStageEvent);
        const img = document.createElement("img");
        img.src = src;
        img.alt = src;
        img.id = src;
        container.appendChild(img);
        return container;
      }

      function initStages(stage_type, parent) {
        return fetch(stage_type)
          .then((response) => response.text())
          .then((html) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const images = doc.querySelectorAll('img[src$=".png"]');
            images.forEach((image) => {
              const src = image.getAttribute("src");
              const container = createImageContainer(src);
              parent.appendChild(container);
            });
          });
      }

      function updateStageBans(stage_bans_dict) {
        Object.entries(stage_bans_dict).forEach(
          ([stage, is_banned_on_server]) => {
            const stage_element = document.getElementById(stage);
            const is_banned_on_client =
              stage_element.parentElement.classList.contains("disabled");
            if (is_banned_on_server != is_banned_on_client) {
              strikeOutStage(stage_element.parentElement);
            }
          }
        );
      }

      // Function to strike out a stage
      function strikeOutStageEvent(event) {
        event.preventDefault();

        // Immediately update strike on client-side
        stage_container = event.currentTarget;
        strikeOutStage(stage_container);

        // Send update to server
        const message = {
          stage: stage_container.querySelector("img").id,
          is_banned: stage_container.classList.contains("disabled"),
        };
        socket.emit("update", message);
        console.log("emitting update");
      }

      function strikeOutStage(stage_container) {
        if (stage_container.classList.contains("disabled")) {
          // clear the strike functionality
          stage_container.classList.remove("disabled");
          const strike = stage_container.querySelector(".strike");
          strike.remove();
        } else {
          // add the strike functionality
          stage_container.classList.add("disabled");
          const strike = document.createElement("div");
          strike.classList.add("strike");
          stage_container.appendChild(strike);
        }
      }

      // the 'init' message will be sent on connection (or reconnection) to the server.
      // We want to:
      // 1) Dynamically populate the Starters and Counterpicks html
      // 2) Synchronize the state of the bans with the server
      socket.on("init", (stage_bans_dict) => {
        console.log("init");
        // We only want to add the stages on first connection. Otherwise we get duplicate stages on reconnection.
        if (!stages_initialized) {
          promise_starters = initStages("Starters", startersContainer);
          promise_counterpicks = initStages(
            "Counterpicks",
            counterpicksContainer
          );
          stages_initialized = true;
          // We await all stage elements to exist before trying to update them.
          Promise.all([promise_starters, promise_counterpicks]).then(() => {
            updateStageBans(stage_bans_dict);
          });
        } else {
          updateStageBans(stage_bans_dict);
        }
      });

      socket.on("update", (stage_bans_dict) => {
        console.log("updating");
        console.log(stage_bans_dict);
        updateStageBans(stage_bans_dict);
      });

      /*
      if (message.action === 'strike') {
        const stage = document.querySelector(`img[src="${message.stage}"]`).parentNode;
        if (message.disabled) {
          // disable the stage
          stage.classList.add('disabled');
          const strike = document.createElement('div');
          strike.classList.add('strike');
          stage.appendChild(strike);
        } else {
          // enable the stage
          stage.classList.remove('disabled');
          const strike = stage.querySelector('.strike');
          strike.remove();
        }
      }*/
    </script>
  </body>
</html>
